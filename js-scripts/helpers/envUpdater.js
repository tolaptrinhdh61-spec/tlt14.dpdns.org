// envUpdater.js
// Nghi·ªáp v·ª•: Update ENV (process.env + .env file + GitHub Actions + Azure Pipeline + system .bashrc)

const fs = require("fs");
const path = require("path");

function valueToString(value) {
  if (value === null || value === undefined) return "";
  if (typeof value === "object") return JSON.stringify(value);
  return String(value);
}

function parseDotEnv(content) {
  const envVars = {};
  content.split("\n").forEach((line) => {
    const match = line.match(/^([^=:#]+)=(.*)$/);
    if (match) envVars[match[1].trim()] = match[2].trim();
  });
  return envVars;
}

function updateProcessEnv(data) {
  let updated = false;

  Object.keys(data).forEach((key) => {
    const value = valueToString(data[key]);
    if (process.env[key] !== value) {
      process.env[key] = value;
      console.log(`üìù Process.env updated: ${key}`);
      updated = true;
    }
  });

  return updated;
}

function updateEnvFile(data, envFilePath) {
  try {
    let envContent = "";
    if (fs.existsSync(envFilePath)) envContent = fs.readFileSync(envFilePath, "utf8");

    const envVars = parseDotEnv(envContent);

    Object.keys(data).forEach((key) => {
      const value = valueToString(data[key]);
      const escapedValue = value.replace(/"/g, '\\"').replace(/\n/g, "\\n");
      envVars[key] = `"${escapedValue}"`;
    });

    const newContent = Object.keys(envVars)
      .map((key) => `${key}=${envVars[key]}`)
      .join("\n");

    fs.writeFileSync(envFilePath, newContent + "\n", "utf8");
    console.log(`üíæ Updated .env file: ${envFilePath}`);
    return true;
  } catch (error) {
    console.error("‚ùå Error updating .env file:", error.message);
    return false;
  }
}

function exportGitHubActionsEnv(data) {
  if (!process.env.GITHUB_ENV) return;

  try {
    let content = "";
    Object.keys(data).forEach((key) => {
      const value = valueToString(data[key]);
      content += `${key}<<EOF\n${value}\nEOF\n`;
    });

    fs.appendFileSync(process.env.GITHUB_ENV, content, "utf8");
    console.log(`üêô Exported to GitHub Actions: ${Object.keys(data).length} variables`);
  } catch (error) {
    console.error("‚ùå Error exporting to GitHub Actions:", error.message);
  }
}

function exportAzurePipelineEnv(data) {
  if (!process.env.SYSTEM_TEAMFOUNDATIONCOLLECTIONURI) return;

  try {
    Object.keys(data).forEach((key) => {
      const value = valueToString(data[key]);
      console.log(`##vso[task.setvariable variable=${key}]${value}`);
    });

    console.log(`‚òÅÔ∏è  Exported to Azure Pipeline: ${Object.keys(data).length} variables`);
  } catch (error) {
    console.error("‚ùå Error exporting to Azure Pipeline:", error.message);
  }
}

function exportSystemEnv(data) {
  if (process.platform === "win32") return;

  try {
    const shellrcPath = path.join(process.env.HOME || "", ".bashrc");
    let commands = "\n# Auto-generated by Firebase Config Listener\n";

    Object.keys(data).forEach((key) => {
      const value = valueToString(data[key]);
      const escapedValue = value.replace(/'/g, "'\\''");
      commands += `export ${key}='${escapedValue}'\n`;
    });

    fs.appendFileSync(shellrcPath, commands, "utf8");
    console.log(`üêß Exported to system .bashrc: ${Object.keys(data).length} variables`);
  } catch (error) {
    console.error("‚ö†Ô∏è  Error exporting to system env:", error.message);
  }
}

function updateEnv(data, options = {}) {
  const envFilePath = options.envFilePath || process.env.ENV_FILE_PATH || ".env";

  if (!data || typeof data !== "object") {
    console.log("‚ö†Ô∏è  No data to update");
    return { updated: false, count: 0 };
  }

  console.log(`\nüìä Updating ${Object.keys(data).length} environment variables...`);

  const updated = updateProcessEnv(data);

  updateEnvFile(data, envFilePath);
  exportGitHubActionsEnv(data);
  exportAzurePipelineEnv(data);
  exportSystemEnv(data);

  return { updated, count: Object.keys(data).length };
}

module.exports = { updateEnv };
